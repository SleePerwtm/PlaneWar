# 游戏玩法

玩家操控飞机移动，目标是操控飞机击落敌机，击落敌机获得分数。

如果飞机撞上敌机，血量减少。当血量减少为0，游戏结束。

飞机默认间隔一段时间发射一枚子弹。

程序会记录游戏时长。

# 需要实现的功能

- 游戏初始化：可用于游戏开始与重新开始时。
    - 创建游戏窗口
    - 初始化分数
    - 初始化游戏时间
    - 绘制角色

- 角色绘制

- 实体移动
    - 移动函数：飞机和子弹都可以使用
    - 键盘控制：控制己方飞机移动
    - 角色移动范围限制

- 角色发射子弹

- 碰撞检测
    - 角色与角色的碰撞
    - 角色与子弹的碰撞

- 计分系统
    - 击败敌方加分
    - 重开时分数清零
    - 时间系统

# 二维向量结构体 Vector2f

| 可见性 | 类型  | 名称 |
| ------ | ----- | ---- |
| public | float | x    |
| public | float | y    |

| 可见性 | 返回类型 | 方法名   |
| ------ | -------- | -------- |
| public |          | 构造函数 |

# 游戏类设计

- 管理类
    - 实体池类 EntityPool
        - 子弹池类 BulletPool
        - 敌机池类 EnemyPool
    - 实体管理类 EntityManager
        - 碰撞处理类 CollisionManager
    - 窗口类 Window
    - 统计信息类 Statistic
- 实体类 Entity
    - 飞机类 Plane
    - 子弹类 Bullet
    - 敌机类 Enemy

## 管理类

### 实体池类 EntityPool

#### 子弹池类 BulletPool

#### 敌机池类 EnemyPool

### 实体管理类 EntityManager

#### 碰撞处理类 CollisionManager

### 窗口类 Window

### 统计信息类 Statistic

| 可见性  | 类型 | 名称       |
| ------- | ---- | ---------- |
| private | int  | 分数 score |
| private | int  | 时间 time  |

## 实体类 Entity

| 可见性    | 类型     | 名称             |
| --------- | -------- | ---------------- |
| protected | Vector2f | 位置 position    |
| protected | Vector2f | 速度 velocity    |
| protected | int      | 半径 radius      |
| protected | int      | 血量 hp          |
| protected | bool     | 是否存活 isAlive |

| 可见性 | 返回类型     | 方法名                  |
| ------ | ------------ | ----------------------- |
| public | virtual void | 绘制 draw               |
| public | virtual void | 移动 move               |
| public | void         | 更新位置 updatePosition |
| public | void         | 设值函数                |
| public | T            | 取值函数                |

### 飞机类 MyPlane

| 可见性 | 类型 | 名称 |
| ------ | ---- | ---- |
|        |      |      |

| 可见性 | 返回类型      | 方法名         |
| ------ | ------------- | -------------- |
| public | void override | 绘制 draw      |
| public | void override | 移动 move      |
| public | void          | 发射子弹 shoot |

### 子弹类 Bullet

| 可见性  | 类型 | 名称                    |
| ------- | ---- | ----------------------- |
| private | bool | 是否为活跃子弹 isActive |

| 可见性 | 返回类型 | 方法名 |
| ------ | -------- | ------ |
| public | void     | 绘制   |
| public | void     | 移动   |

### 敌机类 Enemy

| 可见性 | 类型 | 名称 |
| ------ | ---- | ---- |
|        |      |      |

# 遇到的问题

## 实体纹理可能由多个实体共用一个

### 问题

之前学习 C++ 面向对象编程的时候了解到在对象的复制/拷贝中，可能会由于浅拷贝导致多个实体的纹理地址相同，从而导致重复释放纹理。经过对 raylib 部分源码的阅读，我发现当多个实体使用同一个纹理时，只能使用类似浅拷贝的方式（Texture2D 结构体中记录了纹理在 OpenGL 中的 ID，可以通过不同实体存储相同纹理 ID）来实现以外，暂时没有其他解决办法。而这种办法就会导致内存的非法访问。如果使用类似深拷贝的方式，会导致相同的纹理存储了多个，造成了不必要的消耗。

其实 raylib 库已经对重复释放同一个纹理进行了优化，不会因此导致访问非法内存，但是还是希望能找到一个解决办法来避免重复释放纹理。

### 解决方法

经上网搜索以及 AI 提问，最终选择学习 `std::shared_ptr` 以及 `std::weak_ptr` 的使用，并用一个 `std::unordered_map<std::string, TexturePtr>` 来储存已加载的纹理的地址。

在区分共享纹理和独享纹理的处理上，使用了**强枚举类型** `enum class TextureType`，其中有两个成员：`SHARED` 和 `UNIQUE`。

## 在没有加载图片纹理的时候，用圆形替代

### 问题

先前的代码在没有图片纹理时，无法绘制实体，导致只显示背景的黑色。

### 解决方法

在绘制纹理的时候，通过判断 texture_.id 是否为 0 来判断是否成功加载了纹理，如果没有加载成功，则使用 raylib 库自带的 `DrawCircleV` 函数绘制一个圆形来替代纹理的显示。

## 实现帧数管理

### 问题

应该需要用到时间模块。C++ 内置了 `std::chrono` 模块，不过目前尚未学习，暂时使用 raylib 库自带的帧数设置、获取帧间时间的函数。

## 对 size() 为 0 的容器循环依次进行下标访问赋值 `v[i] = ...`

### 问题

容器 `v` 的大小为 0 时，使用下标访问并赋值 `entities_[i] = std::make_unique<Enemy>(...);` 会导致赋值失败，但不会崩溃，赋值后容器的大小还是 0。

### 解决方法

将循环体中的语句改为 `entities_.push_back(std::make_unique<Enemy>(...));`。

## 键盘输入处理与实体移动边界的实现方法

raylib 库提供了几种函数以及按键宏定义来实现检测键盘按键输入：

| 函数                          | 作用                                                                                                     |
| ----------------------------- | -------------------------------------------------------------------------------------------------------- |
| `bool IsKeyPressed(int key)`  | 如果在本帧中key被按下，返回true；否则返回false（一次按键行为，在多帧中只会有一帧返回1）                  |
| `bool IsKeyDown(int key)`     | 如果在本帧中key处于按下状态，返回true；否则返回false                                                     |
| `bool IsKeyReleased(int key)` | 如果在本帧中key被松开，返回true；否则返回false（一次松开行为，在多帧中只会有一帧返回1）                  |
| `bool IsKeyUp(int key)`       | 如果在本帧中key处于未按下状态，返回true；否则返回false                                                   |
| `int GetKeyPressed()`         | 返回最近的按键，并将其从缓存区中删除；如果缓存区中无按键事件，则返回0                                    |
| `int GetCharPressed()`        | 返回最近输入的字符（ascii码），并将其从缓存区中删除；如果缓存区中无按键事件，则返回0。请勿用其输入中文。 |

### 问题

当前使用的方法为：
- 键盘输入处理：`IsKeyPressed` 以及 `IsKeyReleased`，这样能使得飞机的速度设定更简单，只需要检测到按键按下时，设定速度目标值，按键松开时，将速度目标值设置为 0。否则，若使用 `IsKeyDown`，在设定速度的时候判断会复杂一些。
- 实体移动边界实现：根据当前帧速度，计算当前帧的位置，判断是否超出边界，如果超出边界，则不进行更新。

现在有一个问题就是，如果设定帧数极低，那么飞机的移动会被严重限制，因为一帧的移动距离过长，很容易出界。因此飞机可能距离边界很远的时候就不能再移动了。

另外，由于 raylib 的检测函数的调用频率与设定帧数一致，导致飞机控制检测的精度与位置更新的精度很低，操控不自然。

应该想一种解决方法，在降低目标帧数的时候不会影响对键盘输入的检测频率以及位置更新的频率，能提高对飞机的控制精度。

