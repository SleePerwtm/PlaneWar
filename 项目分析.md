# 游戏玩法

玩家操控飞机移动，目标是操控飞机击落敌机，击落敌机获得分数。

如果飞机撞上敌机，血量减少。当血量减少为0，游戏结束。

飞机默认间隔一段时间发射一枚子弹。

程序会记录游戏时长。

# 需要实现的功能

- 游戏初始化：可用于游戏开始与重新开始时。
    - 创建游戏窗口
    - 初始化分数（通过 `Statistic::score_`）
    - 初始化游戏时间（通过 `std::chrono::steady_clock`）
    - 初始化玩家、敌人管理器、子弹管理器、碰撞管理器

- 角色绘制（纹理或圆形替代）

- 实体移动
    - 移动函数：所有实体通过 `updatePosition()` 更新位置
    - 键盘控制：使用 `IsKeyPressed` 和 `IsKeyReleased` 控制玩家移动
    - 角色移动范围限制：通过检查边界来限制实体移动

- 角色发射子弹（通过 `BulletManager` 的生成间隔管理）

- 碰撞检测
    - 玩家与敌机的碰撞（玩家血量减少）
    - 敌机与子弹的碰撞（敌机销毁、增加分数）
    - 子弹与玩家的碰撞判断（防止误伤）

- 计分系统
    - 击败敌机加分（通过 `Statistic::addScore()`）
    - 重启时分数清零（通过 `Statistic::resetStatistics()`）
    - 时间系统（通过 `std::chrono` 追踪游戏已进行时间）

- 游戏状态管理（`Status::PRE_GAME`、`Status::RUNNING`、`Status::GAME_OVER`、`Status::RESTART`）

# 配置系统

项目使用 `config.h` 中的全局命名空间 `Config` 来集中管理所有常量配置，包括：

| 配置类别                | 内容                                               |
| ----------------------- | -------------------------------------------------- |
| `Config::Window`        | 窗口宽度、高度、标题、帧率                         |
| `Config::Keyboard`      | 按键映射（方向键：W/A/S/D）                        |
| `Config::Player`        | 玩家初始位置、速度、加速度、血量、移动速度、缩放等 |
| `Config::EnemyPool`     | 敌人池大小、初始参数、速度范围                     |
| `Config::EnemyManager`  | 敌人生成间隔                                       |
| `Config::BulletPool`    | 子弹池大小、初始参数、速度                         |
| `Config::BulletManager` | 子弹生成间隔                                       |

此设计便于统一管理游戏参数，支持快速调试与平衡。

# 游戏类设计

## 游戏主类（Game）
- 游戏状态：`Status` 枚举（`PRE_GAME`、`RUNNING`、`GAME_OVER`、`RESTART`）
- 包含的对象：
  - 窗口（`Window`）
  - 玩家（`Player`）
  - 敌人管理器（`EnemyManager`）
  - 子弹管理器（`BulletManager`）
  - 碰撞管理器（`CollisionManager`）

## 管理类设计

### 实体管理器模板类（EntityManager<T>）
- 模板设计，用于管理实体池中的实体
- 提供通用的生成、回收、绘制、位置更新接口

### 敌人管理器（EnemyManager）
- 继承自 `EntityManager<EnemyPool>`
- 管理敌人实体的生成、回收、位置更新、绘制
- 支持敌人重置

### 子弹管理器（BulletManager）
- 继承自 `EntityManager<BulletPool>`
- 管理子弹实体的生成、回收、位置更新、绘制
- 与玩家关联，支持发射子弹

### 碰撞管理器（CollisionManager）
- 处理玩家、敌机、子弹之间的碰撞检测
- 更新实体状态（伤害、销毁等）

### 实体池类（EntityPool）
- 使用 `std::vector<std::unique_ptr<T>>` 存储实体
- 提供实体的创建、激活、停用接口

#### 子弹池类（BulletPool）
- 继承自 `EntityPool`
- 管理固定数量的子弹实体

#### 敌人池类（EnemyPool）
- 继承自 `EntityPool`
- 管理固定数量的敌人实体

### 窗口类（Window）
- 管理 raylib 窗口的创建、绘制、关闭
- 提供背景色设置、帧率控制、FPS 显示等功能

### 统计信息类（Statistic）
- 静态类，包含：
  - `score_`：当前分数
  - `start_time_`：游戏开始时刻（`std::chrono::steady_clock::time_point`）
  - `time_passed_`：游戏已进行时间（`std::chrono::duration<float>`）
- 提供分数增加、时间更新、重置等接口

## 实体类（Entity）

### 基础属性

| 可见性    | 类型        | 名称                   |
| --------- | ----------- | ---------------------- |
| protected | Vector2     | 位置 position_         |
| protected | Vector2     | 速度 velocity_         |
| protected | Vector2     | 加速度 acceleration_   |
| protected | int         | 半径 radius_           |
| protected | int         | 血量 hp_               |
| protected | bool        | 是否激活 is_active_    |
| protected | TexturePtr  | 纹理 texture_          |
| protected | TextureType | 纹理类型 texture_type_ |
| protected | float       | 缩放倍数 scale_        |

### 基础方法

| 可见性 | 返回类型        | 方法名                      |
| ------ | --------------- | --------------------------- |
| public | virtual void    | 更新位置 updatePosition     |
| public | virtual void    | 绘制 draw                   |
| public | virtual void    | 加载纹理 loadTexture        |
| public | virtual void    | 设置速度 set_velocity       |
| public | virtual void    | 设置位置 set_position       |
| public | virtual void    | 设置加速度 set_acceleration |
| public | virtual void    | 设置血量 set_hp             |
| public | virtual Vector2 | 获取速度 get_velocity       |
| public | virtual Vector2 | 获取位置 get_position       |
| public | virtual Vector2 | 获取加速度 get_acceleration |
| public | virtual int     | 获取血量 get_hp             |
| public | virtual int     | 获取半径 get_radius         |
| public | virtual void    | 激活 activate               |
| public | virtual void    | 停用 deactivate             |
| public | virtual bool    | 获取激活状态 is_active      |
| public | virtual void    | 受伤 damage                 |

### 玩家类（Player）

继承自 `Entity`，额外实现：
- 保存初始状态的 `PlayerData` 结构体（用于重置）
- `resetPlayer()` 方法：恢复到初始状态

### 子弹类（Bullet）

继承自 `Entity`，基础实现，不额外添加特殊方法。

### 敌机类（Enemy）

继承自 `Entity`，基础实现，不额外添加特殊方法。

## 纹理管理设计

使用强枚举类型 `enum class TextureType`：
- `SHARED`：共享纹理，多个实体可以共用同一纹理（通过 `std::shared_ptr<Texture2D>` 管理）
- `UNIQUE`：独享纹理，每个实体拥有独立的纹理副本

使用全局 `std::unordered_map<std::string, TexturePtr>` 缓存已加载的共享纹理，避免重复加载。

# 遇到的问题

## 实体纹理可能由多个实体共用一个

### 问题

之前学习 C++ 面向对象编程的时候了解到在对象的复制/拷贝中，可能会由于浅拷贝导致多个实体的纹理地址相同，从而导致重复释放纹理。经过对 raylib 部分源码的阅读，我发现当多个实体使用同一个纹理时，只能使用类似浅拷贝的方式（Texture2D 结构体中记录了纹理在 OpenGL 中的 ID，可以通过不同实体存储相同纹理 ID）来实现以外，暂时没有其他解决办法。而这种办法就会导致内存的非法访问。如果使用类似深拷贝的方式，会导致相同的纹理存储了多个，造成了不必要的消耗。

其实 raylib 库已经对重复释放同一个纹理进行了优化，不会因此导致访问非法内存，但是还是希望能找到一个解决办法来避免重复释放纹理。

### 解决方法

经上网搜索以及 AI 提问，最终选择学习 `std::shared_ptr` 以及 `std::weak_ptr` 的使用，并用一个 `std::unordered_map<std::string, TexturePtr>` 来储存已加载的纹理的地址。

在区分共享纹理和独享纹理的处理上，使用了**强枚举类型** `enum class TextureType`，其中有两个成员：`SHARED` 和 `UNIQUE`。

## 在没有加载图片纹理的时候，用圆形替代

### 问题

先前的代码在没有图片纹理时，无法绘制实体，导致只显示背景的黑色。

### 解决方法

在绘制纹理的时候，通过判断 texture_.id 是否为 0 来判断是否成功加载了纹理，如果没有加载成功，则使用 raylib 库自带的 `DrawCircleV` 函数绘制一个圆形来替代纹理的显示。

## 实现帧数管理

### 问题

应该需要用到时间模块。C++ 内置了 `std::chrono` 模块，不过目前尚未学习，暂时使用 raylib 库自带的帧数设置、获取帧间时间的函数。

## 对 size() 为 0 的容器循环依次进行下标访问赋值 `v[i] = ...`

### 问题

容器 `v` 的大小为 0 时，使用下标访问并赋值 `entities_[i] = std::make_unique<Enemy>(...);` 会导致赋值失败，但不会崩溃，赋值后容器的大小还是 0。

### 解决方法

将循环体中的语句改为 `entities_.push_back(std::make_unique<Enemy>(...));`。

## 键盘输入处理与实体移动边界的实现方法

raylib 库提供了几种函数以及按键宏定义来实现检测键盘按键输入：

| 函数                          | 作用                                                                                                     |
| ----------------------------- | -------------------------------------------------------------------------------------------------------- |
| `bool IsKeyPressed(int key)`  | 如果在本帧中key被按下，返回true；否则返回false（一次按键行为，在多帧中只会有一帧返回1）                  |
| `bool IsKeyDown(int key)`     | 如果在本帧中key处于按下状态，返回true；否则返回false                                                     |
| `bool IsKeyReleased(int key)` | 如果在本帧中key被松开，返回true；否则返回false（一次松开行为，在多帧中只会有一帧返回1）                  |
| `bool IsKeyUp(int key)`       | 如果在本帧中key处于未按下状态，返回true；否则返回false                                                   |
| `int GetKeyPressed()`         | 返回最近的按键，并将其从缓存区中删除；如果缓存区中无按键事件，则返回0                                    |
| `int GetCharPressed()`        | 返回最近输入的字符（ascii码），并将其从缓存区中删除；如果缓存区中无按键事件，则返回0。请勿用其输入中文。 |

### 问题

当前使用的方法为：
- 键盘输入处理：`IsKeyPressed` 以及 `IsKeyReleased`，这样能使得飞机的速度设定更简单，只需要检测到按键按下时，设定速度目标值，按键松开时，将速度目标值设置为 0。否则，若使用 `IsKeyDown`，在设定速度的时候判断会复杂一些。
- 实体移动边界实现：根据当前帧速度，计算当前帧的位置，判断是否超出边界，如果超出边界，则不进行更新。

现在有一个问题就是，如果设定帧数极低，那么飞机的移动会被严重限制，因为一帧的移动距离过长，很容易出界。因此飞机可能距离边界很远的时候就不能再移动了。

另外，由于 raylib 的检测函数的调用频率与设定帧数一致，导致飞机控制检测的精度与位置更新的精度很低，操控不自然。

应该想一种解决方法，在降低目标帧数的时候不会影响对键盘输入的检测频率以及位置更新的频率，能提高对飞机的控制精度。
